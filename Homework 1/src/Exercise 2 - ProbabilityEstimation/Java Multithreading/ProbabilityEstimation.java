import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ProbabilityEstimation {
    //2 patterns we want to calculate the probability of appearing first.
    static String pattern1;
    static String pattern2;

    //default values for the number of trials and the number of threads used.
    static int trials = 1000000;
    static int threadsNum = 10;

    //total occurrences found from all the threads.
    static int pattern1Found = 0;
    static int pattern2Found = 0;

    public static void main(String[] args) throws InterruptedException {
        //get arguments from the args and depending on the length, process them.
        pattern1 = args[0];
        pattern2 = args[1];

        //if there is a third argument.
        if(args.length>2){
            trials = Integer.parseInt(args[2]);
        }

        //if there is a forth argument.
        if(args.length>3){
            threadsNum = Integer.parseInt(args[3]);
        }

        //create array of threads.
        Thread[] threads = new Thread[threadsNum];

        for(int i=0;i<threadsNum;i++){
            //create custom threads giving their rank as a property.
            threads[i] = new GenerateCoinFlips(i);

            //start each thread.
            threads[i].start();
        }

        //join each thread with the main thread.
        for(Thread thread:threads){
            thread.join();
        }

        //print the result.
        System.out.println("Estimated values with "+trials+" random experiments with "+threadsNum+" threads:");
        System.out.println("The probability that "+pattern1+" appears first is "+calculateProbability(pattern1Found));
        System.out.println("The probability that "+pattern2+" appears first is "+calculateProbability(pattern2Found));
    }

    //just to make sure the number of trials isn't 0.
    static double calculateProbability(int occurrences){
        return trials!=0?(double)occurrences/trials:0;
    }

    //class inheriting from Thread class.
    static class GenerateCoinFlips extends Thread{
        //Pattern generated by flipping coins to be compared to our patterns.
        private String patternGenerated = "";
        //rank to separate the work as evenly as possible.
        private final int rank;

        //number of locally found patterns by this thread.
        private int pattern1FoundHere = 0;
        private int pattern2FoundHere = 0;

        //constructor.
        GenerateCoinFlips(int rank){
            this.rank = rank;
        }

        //override the run method.
        @Override
        public void run(){
            //while the thread has not reached the number of trials.
            for(int i=rank;i<trials;){
                //generate a random H for heads and T for tails.
                String randomChar = ((int)(Math.random()*2) == 1) ? "H":"T";

                //concatenate the pattern it generated until now with the new "H":"T" char.
                patternGenerated = patternGenerated.concat(randomChar);

                //if the generated pattern ending matches with one of the patterns, increment its count and reset the pattern generated.
                if(patternGenerated.endsWith(pattern1)){
                    pattern1FoundHere++;
                    patternGenerated = "";
                    //helps since i%threadNum = rank always.
                    i+=threadsNum;
                }
                if(patternGenerated.endsWith(pattern2)){
                    pattern2FoundHere++;
                    patternGenerated = "";
                    //helps since i%threadNum = rank always.
                    i+=threadsNum;
                }
            }

            //synchronize this block to assure data integrity.
            synchronized (this) {
                pattern1Found += pattern1FoundHere;
                pattern2Found += pattern2FoundHere;
            }
        }
    }
}
